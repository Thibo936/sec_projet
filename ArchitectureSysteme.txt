Ce document est temporaire et amené à être modifié
Voici un échantillon de la structure utilisée dans ce document, incluant les conventions de nomenclatures utilisées:

----
  Version numéro de version: Etat
  - Modification par rapport à la précédente version
  -- Note sur la priorité pour la version suivante
----

Classe
  nomAttribut: type

  nomFonction(premiere_variable: type, deuxieme_variable: type = valeur par défaut): type retour
    - spécification à propos de la fonction
      -- cas particulier de la spécification précédente
      -- cas particulier de la spécification précédente
    - spécification à propos de la fonction # Nom de l'auteur: Note, observation, commentaire sur une ligne #

  // fonction ou attribut dont l'utilité ou la position est incertaine

****
  Nom de l'auteur : Notes, observations, commentaires
  sur plusieurs lignes
  Nom de l'auteur: Notes, observations, commentaires
  sur plusieurs lignes
****
__________________________________________________________________

****
  Lia: S'il vous plaît, suivez les conventions au dessus, et maintenez bien ce document. Je sais que ça paraît énorme comme demande, mais ça nous permettra d'être clairs, et de ne pas attendre sur le travail d'untel pour faire le notre.
  Sans oublier que ce sera utile pour le rapport.
****

----
  Version 0.1: Version brouillon
    -- Cruel manque des parties réseau et base de données
    -- Nombreux points à éclaircir
----

Client
  nom: string
  motDePasse: string
  cle: string

****
  Lia: Comme on veut que le client reste anonyme, je pensais à une liste qui assoicierait l'identifiant d'une enchère à un mot aléatoire hashé. On ajouterai ça aux attributs du client.
  Questions, est-ce qu'on gère ça dans la classe client directement ? comment nommer cet attribut ? est-ce un tuple ou un autre objet ?
****

  new Client(n: string, mdp: string, c: string): void

  // genererCle(): string

  // hash(message: string): string
  
  authentification(): void
    - demande un nom au client
    - demande un mot de passe au client
    - envoie la demande d'authentification au serveur
    - gère la réponse reçue
      -- si connexion établie, afficher "Bonjour " + nom
      -- sinon, gérer l'erreur
  
  proposeEnchere(enchere_id): void
    - demande le prix proposé au client
    - envoie la proposition au serveur
    - gère la réponse reçue
      -- si enchère établie, afficher "Votre enchère a été enregistrée"
      -- sinon, gérer l'erreur

  consulteEncheresGeneral(): void
    - envoie une demande de la liste des enchères en cours au serveur
    - gère la réponse reçue
      -- si liste vide reçue, afficher "Il n'y aucune d'enchères en cours"
      -- sinon, si liste reçue, afficher les enchères
      -- sinon, gérer l'erreur

  consulteEncheresRemportees(): void
    - envoie une demande de la liste des enchères emportées par ce client
    - gère la réponse reçue
      -- si liste vide reçue, afficher "Vous n'avez pas remporté d'enchères"
      -- sinon, si liste reçue, afficher les enchères
      -- sinon, gérer l'erreur

  afficheGagnant(enchere: Enchere # Lia: ou un string formaté #): void
    - affiche l'enchère # Lia: popup? #

  envoieMDP(): string


  toString(): string
    - renvoie les informations du client sous la forme nom: cle.

Serveur
  clients: Client list
  encheresEnCours: Enchere list
  encheresFinies : Enchere list
  // nbEncheres: int # Lia: Pour ne pas avoir à vérifier à chaque enchère quel sera son identifiant #

  new Serveur(): void

  ajouteEnchere(enchere: Enchere): void

  reveleGagnant(enchere_id: int): void
    - recupère l'enchère correspondant à enchere_id
    - récupère les informations du gagnant et les modifie dans l'enchère (passe d'un gagnant anonyme à publique)
    - envoie l'enchère à tous les membres de clients

  clotEnchere(enchere_id: int): void
    # Lia: est-ce qu'on vérifie que l'enchère correspondant à enchere_id est terminée (timer à 0) ici ? #
    - déplace une enchère de encheresEnCours à encheresFinies

  gerePropositionEnchere(enchere_id: int, prix: int, client_hash: string): void
    - vérifie que l'enchère avec enchere_id est valide
    - vérifie que le prix proposé soit supérieur au prix courant
      -- si supérieur, actualise le client gagnant
    - envoie un message de confirmation ou d'erreur au client

  envoieListeEncheresEnCours(): Enchere list

  ajouteClient(client_nom: string, client_mdp: string): void
    - crée le client
    # Lia: Comment on gère la clé du client ? #

  ajouteEnchere()

Enchere
  id: int
  nom: string
  prix: int # Lia: Le prix à l'initialisation est le prix de départ. Il devient ensuite le prix de la meilleure enchère #
  temps: Timer # Lia: Dépendant du langage, la gestion du temps sera différente. En revanche, je propose qu'on gère les effets (le temps écoulé) dans Enchere directement. A voir la nécessité d'un message réseau pour signifier la fin d'une enchère #
  meilleurCandidat: string

  new Enchere(enchere_id: int, n: string, p: int, t: Timer): void
    - Le meilleur candidat est initialisé à null.

  actualiseEnchere(p: int, candidat: string): void

  toString(): string
    - Envoie l'enchère sous la forme (id)Nom. \nMeilleure enchère: prix par meilleurCandidat